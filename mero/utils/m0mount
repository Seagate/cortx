#!/usr/bin/env bash
# set -x
# Script to startup local/remote services and mount Mero file system
#
# - The script requires the build path to be available on all the nodes.
#   (This can be easily shared via NFS from some one node.)
# - The script uses ssh and scp to operate remotely. It requires that the
#   remote service nodes have this node's public certificate in
#   their .ssh/authorized_keys file.  If services are defined on the local
#   host then it should be possible to ssh into the local host.
# - The script requires WORK_ARENA (var/mero) to be shared among the nodes
#   of the same Titan/SSU.

# Before running the script, make sure you configured
# the IP/IB addresses of your setup correctly here (see below).

# Here is some configuration info (as for the time of writing this)
# about Titan nodes in Fremont lab:
#
# +----------------------------------------------------------------+
# | Hostname   |   IP-address   |    IB-address   |  IPMI-address  |
# +------------+----------------+-----------------+----------------+
# | sjt00-c1   |  10.76.50.161  |  172.18.50.161  |  10.76.50.162  |
# | sjt00-c2   |  10.76.50.163  |  172.18.50.163  |  10.76.50.164  |
# | sjt02-c1   |  10.76.50.40   |  172.18.50.40   |  10.76.50.42   |
# | sjt02-c2   |  10.76.50.45   |  172.18.50.45   |  10.76.50.47   |
# +----------------------------------------------------------------+
#
# Please note that in-order to avoid detecting devices of the same titan SSU
# more than once, we use the part of controller's hostname before the first
# occurance of '-'. E.g. in above configuration sjt00-c1 and sjt00-c2, c1 and
# c2 both are part of the same SSU identified by sjt00.
# Please see servers_start() for its implementation.
#
# Use root/Xyratex to login to any node.
#
# To see the serial console of sjt02-c1 node, for example,
# use this command:
# $ ipmitool -I lanplus -H 10.76.50.42 -U admin -P admin sol activate
#
# To reset the power:
# $ ipmitool -H 10.76.50.42 -U admin -P admin power reset
#
# Provide a list of servers, represented by the 2-tuple of node IP and end
# point, in the SERVICES array.
#
#   e.g. 	sjt02-c2 172.18.50.45@o2ib:12345:33:101
#
# - There are an even number of records in the list.
# - The number of server records is the POOL_WIDTH.

# This example uses co-located remote ioservices.
#HOSTS_SERVICES=(
#	sjt02-c2 172.18.50.45@o2ib:12345:41:101
#	sjt02-c2 172.18.50.45@o2ib:12345:41:102
#	sjt02-c2 172.18.50.45@o2ib:12345:41:103
#	sjt02-c2 172.18.50.45@o2ib:12345:41:104
#)
# IMPORTANT! Keep the same nodes together in the list
# (the code depends on this).
#

M0_SRC_DIR="$(readlink -f $0)"
M0_SRC_DIR="${M0_SRC_DIR%/*/*}"

. $M0_SRC_DIR/m0t1fs/linux_kernel/st/m0t1fs_common_inc.sh  # build_conf
. $M0_SRC_DIR/m0t1fs/linux_kernel/st/m0t1fs_server_inc.sh  # conf_ios_device_setup

usage()
{
	setup_params
	cat <<.
Usage:

$ sudo m0mount [-Laclsqv] [-d NUM] [-p NUM] [-n NUM] [-m 1|0]

Where:
-a: Use AD stobs
    configure the services to run on ad stobs.
    it automatically detects and make configuration files
    for the Titan disks.
    Before using ad option make sure the disks are online:
    $ sudo ~root/gem.sh dumpdrives
    Turn them on if needed:
    $ sudo ~root/gem.sh powerondrive all
    If 'local' option is set also - /dev/loopX disks
    should be prepeared for ad stobs beforehand.

-c: Client only mode, don't start servers.

-o: Mount client in oostore mode.

-l: Use loop device for ad stob configuration

-s: Setup loop devices

-L: Use local machine configuration.
    start the services on the local host only,
    it is convenient for debugging on a local devvm.
    The number of services is controlled by SERVICES_NR
    variable. The default number is $SERVICES_NR.

-v: Increase verbosity.

-h: Print this help.

-m: Run m0mkfs before starting m0d.

-n NUM: Start 'NUM' number of local m0d. (default is $SERVICES_NR)

-d NUM: Use NUM number of data units. (default is $NR_DATA)

-k NUM: Use NUM number of parity units. (default is $NR_PARITY)

-p NUM: Use NUM as pool width. (default is $POOL_WIDTH)

-q: Dont wait after mounting m0t1fs, exit immediately. (default is wait)

.
}

OPTIONS_STRING="acln:d:k:p:u:qhLsvmo"

# This example puts 3 ioservices on 3 nodes
# SERVICES and HOSTS are populated from this array for non-local configuration.
HOSTS_SERVICES=(
        #sjt02-c1 172.18.50.40@o2ib:12345:41:101
        sjt02-c2 172.18.50.45@o2ib:12345:41:101
        #sjt00-c1 172.18.50.161@o2ib:12345:41:101
)

SERVICES=()

# HOSTS should match the SERVICES endpoints above with 1 <-> 1 relationship.
HOSTS=()

MDSERVICES=()

declare -A NODE_UUID
NODE_UUID[sjt02-c1]=30ab1a00-8085-40d1-a557-8996e2369a7a
NODE_UUID[sjt02-c2]=6485c5f9-fbde-4e39-8c6a-bb9d46b3bf8a
NODE_UUID[sjt00-c1]=54b0a56a-56ba-41a8-9caf-3f3981cfdf69
NODE_UUID[sjT07-s1]=316c681d-2723-463c-b0f4-8e00dff22edd
NODE_UUID[sjT07-s2]=46b0b588-c5bb-4ca4-9962-020521ec6f49

# to make command output parsing predictable
LC_MESSAGES=C

THIS_HOST=$(hostname)
DISKS_PATTERN="/dev/disk/by-id/scsi-35*"

STOB=linux
client_only=0
run_mkfs=0
use_loop_device=0
setup_loops_p=0
loop_used=-1
setup_local_server_config=0
wait_after_mount=1
verbosity=0
#@todo Eliminate this after using the proc fid from the configuration.
proc_fid_ios="'<0x7200000000000001:0>'"
proc_fid_mds="'<0x7200000000000001:1>'"
proc_fid_ha="'<0x7200000000000001:2>'"
proc_fid_confd="'<0x7200000000000001:3>'"

M0MKFS_TRACE_MASK=m0d,fop,cob,ioservice,stob,adstob,extmap,conf
M0MKFS_TRACE_LEVEL=warn+
M0MKFS_TRACE_CONTEXT=short

M0D_TRACE_MASK=m0d,fop,cob,ioservice,stob,adstob,balloc,extmap,conf
M0D_TRACE_LEVEL=warn+
M0D_TRACE_CONTEXT=short

# kernel space tracing parameters
M0T1FS_TRACE_MASK=m0t1fs,fop,rpc,formation
M0T1FS_TRACE_CONTEXT=short
M0T1FS_TRACE_LEVEL=warn+

# Local mount data
MP=/mnt/m0

# The file system TMID
FSTMID=1

# Remote work arena
WORK_ARENA=${SANDBOX_DIR:-/var/mero}

CONF_FILE=$WORK_ARENA/conf.xc

# transport related variables
XPT=lnet
# m0d flags
XPT_MEMSIZE=163840
XPT_QUEUELEN=16
XPT_SETUP="-m $XPT_MEMSIZE -q $XPT_QUEUELEN"
# m0mero module params
XPT_PARAM_R="max_rpc_msg_size=163840 tm_recv_queue_min_len=1"	# remote host
XPT_PARAM_L="max_rpc_msg_size=163840 tm_recv_queue_min_len=48"	# local host

KTRACE_FLAGS="trace_immediate_mask=$M0T1FS_TRACE_MASK \
trace_print_context=$M0T1FS_TRACE_CONTEXT trace_level=$M0T1FS_TRACE_LEVEL"

# track hosts that have been initialized in an associative array
declare -A SETUP

# track hosts on which servers have been started
declare -A STARTED

# A file whose sum we can check
LSUM=

###########
# functions

if [ $0 = "/usr/bin/m0mount" ]; then
	M0D=/usr/bin/m0d
	M0MKFS=/usr/sbin/m0mkfs
	M0LAYOUT=/usr/sbin/m0layout
	SUMFILE=$M0D
	MERO_KO_LOAD_CMD="modprobe m0mero"
	GF_KO_LOAD_CMD="modprobe m0gf"
else
	M0D=$M0_SRC_DIR/mero/m0d
	M0MKFS=$M0_SRC_DIR/utils/mkfs/m0mkfs
	M0LAYOUT=$M0_SRC_DIR/utils/m0layout
	SUMFILE=$M0_SRC_DIR/mero/.libs/m0d
	MERO_KO_LOAD_CMD="insmod $M0_SRC_DIR/m0mero.ko"
	GF_KO_LOAD_CMD="insmod $M0_SRC_DIR/extra-libs/gf-complete/src/linux_kernel/m0gf.ko"
fi

#
# Execute supplied command line.
#
# Use this in case command's output is consumed by the caller.
#
function l_run ()
{
	if [ $verbosity -gt 0 ] ;then
		echo "# $*" >/dev/tty
	fi
	eval $*
}

#
# Similar to l_run, but discards command output.
#
# Use this when command is needed only for its side-effects.
#
function l_do ()
{
	if [ $verbosity -gt 1 ] ;then
		echo "# $*" >/dev/tty
		eval $*
	elif [ $verbosity -gt 0 ] ;then
		echo "# $*" >/dev/tty
		eval $* > /dev/null
	else
		eval $* > /dev/null
	fi
}

l_do modprobe lnet
l_do lctl network up &>> /dev/null
LOCAL_NID=`lctl list_nids | head -1`
LOCAL_EP=$LOCAL_NID:12345:41:10

setup_local_params()
{
	NODE_UUID[$THIS_HOST]=02e94b88-19ab-4166-b26b-91b51f22ad91

	SERVICES_NR=${SERVICES_NR:-4}
	POOL_WIDTH=${POOL_WIDTH:-$SERVICES_NR}
	if ((POOL_WIDTH < SERVICES_NR)); then
		SERVICES_NR=$POOL_WIDTH
	fi

	unset SERVICES
	unset HOSTS
	# Update each field of SERVICES array with local node values
	# Update hostname and end point addresses
	for ((i = 0; i < $SERVICES_NR; i++)); do
		HOSTS[i]=$THIS_HOST
		SERVICES[i]="${LOCAL_EP}"$((i+1))
	done

	if [ $use_loop_device -eq 1 ]; then
		DISKS_PATTERN="/dev/loop*"
	fi
}

function r_run ()
{
	H=$1
	shift
	echo "# ssh root@$H $*" >/dev/tty
	ssh root@$H $*
}

function setup_host ()
{
	H=$1
	EP=$2  # template for kernel end point address
	if [ "x${NODE_UUID[$H]}" == "x" ]; then
		echo ERROR: unknown uuid of the node $H
		return 1
	fi
	echo Setting up host $H
	# check for local host
	local RUN
	local XPT_PARAM
	if [ $H != $THIS_HOST ]; then
		RUN="r_run $H"
		XPT_PARAM=$XPT_PARAM_R
	else
		RUN=l_run
		XPT_PARAM=$XPT_PARAM_L
	fi
	# check if a mero process is running
	local SVRS=$($RUN pgrep m0d)
	if [ -n "$SVRS" ]; then
		echo $SVRS
		echo ERROR: m0d process already running on $H
		return 1
	fi
	if [ $H != $THIS_HOST ]; then
		# ensure that the build path is accessible
		local RSUM=$($RUN sum $SUMFILE)
		if [ "$RSUM" != "$LSUM" ]; then
			echo ERROR: Build tree not accessible on $H
			return 1
		fi
	fi
	# use the specified end point as a template for the file system addr
	KEP="${EP%:*}:$FSTMID"
	# enable lnet and load our kernel modules
	$RUN modprobe lnet
	$RUN lctl network up
	if [ $? -ne 0 ]; then
		echo  ERROR: Unable to configure LNet
		return 1
	fi
	$RUN rmmod m0mero m0gf 2>/dev/null
	$RUN $GF_KO_LOAD_CMD
	if [ $? -ne 0 ]; then
		echo ERROR: Failed to load m0gf module on $H
		return 1
	fi
	$RUN $MERO_KO_LOAD_CMD local_addr=$KEP $XPT_PARAM $KTRACE_FLAGS \
		node_uuid=${NODE_UUID[$H]} trace_buf_size=$((128 * 1024 * 1024))
	if [ $? -ne 0 ]; then
		echo ERROR: Failed to load m0mero module on $H
		$RUN rmmod m0gf
		return 1
	fi
	return 0
}

function setup_hosts ()
{
	if [ $client_only -eq 0 ]; then
		for ((i=0; i < ${#SERVICES[*]}; i++)); do
			H=${HOSTS[$i]}
			EP=${SERVICES[$i]}
			if [ X${SETUP[$H]} = X ]; then
				setup_host $H $EP || return 1
				SETUP[$H]=$H
			fi
		done
	fi
	if [ X${SETUP[$THIS_HOST]} = X ]; then
		setup_host $THIS_HOST $LOCAL_EP || return 1
		SETUP[$THIS_HOST]=$THIS_HOST
	fi
	return 0
}

function teardown_host ()
{
	H=$1
	echo Tearing down host $H
	if [ $H != $THIS_HOST ]; then
		RUN="r_run $H"
	else
		RUN=l_run
	fi
	$RUN rmmod m0mero m0gf
	return 0
}

function teardown_hosts ()
{
	for H in ${SETUP[*]} ; do
		teardown_host $H
	done
}

function gen_device_conf_ids()
{
	local devs=0
	local ios=1
	local ids=""
	local id_count=0
	local disks_per_ios=0
	local i=0

	for (( i = 1; ((i <= $POOL_WIDTH)); i++ )); do
		conf_ios_device_setup $i $id_count id_count "$ids" ids
		disks_per_ios=`expr $DISKS_SH_NR - 1`
		devs=$(expr $disks_per_ios  \* $ios)
		if [ $i -eq $devs ]; then
			IOS_DEV_IDS[`expr $ios - 1`]="[$id_count: $ids]"
			ios=`expr $ios + 1`
			ids=""
			id_count=0
		fi
	done
}

function gen_disks_conf_files()
{
	local dev_id=$1
	local DISKS_SH=$WORK_ARENA/find_disks.sh
	local SF=/tmp/nh.$$

	cat <<EOF >$SF
#!/usr/bin/env bash

#This script helps to create a disks configuration file on Titan controllers.
#
#The file uses yaml format, as desired by the m0d program.
#The script uses the fdisk command and extracts only the unused disks
#present on the system (i.e without valid partition table).
#
#Below illustration describes a typical disks.conf entry,
#
#===========================================================
#Device:
#       - id: 1
#	  filename: /dev/sda
#       - id: 2
#	  filename: /dev/sdb
#===========================================================
#

# number of disks to split by
DISKS_SH_NR=$DISKS_SH_NR

i=$dev_id; j=1; f=0;

echo "Device:" > disks.conf

devs=\`ls $DISKS_PATTERN | grep -v part\`

for dev in \$devs; do
	partitions=\$(partprobe -ds \$dev 2>/dev/null)
	# if \$dev is a valid block device (zero exit code of partprobe)
	# and it doesn't contain any partition table (output of partprobe is empy)
	if [[ \$? -eq 0 && -z \$partitions ]]; then
		if [ \$j -eq 0 ]; then
			echo "Device:" > disks\$f.conf
			echo "   - id: 0" >> disks\$f.conf
			echo "     filename: \$dev" >> disks\$f.conf
		else
			echo "   - id: \$i" | tee -a disks.conf >> disks\$f.conf
			echo "     filename: \$dev" | tee -a disks.conf >> disks\$f.conf
			i=\`expr \$i + 1\`
		fi
		j=\`expr \$j + 1\`
		[ \$j -eq \$DISKS_SH_NR ] && j=1 && f=\`expr \$f + 1\`
	fi
done
exit 0
EOF
	if [ $H != $THIS_HOST ]; then
		l_do scp $SF $H:$DISKS_SH
	else
		$RUN cp $SF $DISKS_SH
	fi
	if [ $? -ne 0 ]; then
		echo ERROR: Failed to copy script file to $H
		return 1
	fi

	$RUN "(cd $WORK_ARENA && sh $DISKS_SH)"
	if [ $? -ne 0 ]; then
		echo ERROR: Failed to get disks list on $H
		return 1
	fi

	MAX_DISK_ID=`$RUN grep "id:" $WORK_ARENA/disks.conf | tail -1 | awk '{print $3}'`
}

function mkfs()
{
	local DIR="$1"
	local STOB="$2"
	local CONF="$3"
	local EP="$4"
	local tm_id=$(echo $EP | cut -d: -f5)
	local MKFS_EP=${EP%:*:*}:35:$tm_id

	echo Running mkfs...
	$DO "rm -rf $DIR; mkdir $DIR"
	$RUN "cd $DIR && \
M0_TRACE_IMMEDIATE_MASK=$M0MKFS_TRACE_MASK \
M0_TRACE_LEVEL=$M0MKFS_TRACE_LEVEL \
M0_TRACE_PRINT_CONTEXT=$M0MKFS_TRACE_CONTEXT \
$M0MKFS $STOB -D $DIR/db -S $DIR/stobs \
-A linuxstob:$DIR/addb-stobs $MKFS_EP $CONF" || {
		echo "ERROR: Failed to m0mkfs for $(basename $DIR) on $H"
		return 1
	}
}

function start_server ()
{
	H=$1
	EP=$2
	I=$3
	local dcf_id=$4

	echo "Starting server with end point $EP on host $H"
	local DO
	local RUN
	if [ $H != $THIS_HOST ]; then
		DO="r_run $H"
		RUN="r_run $H"
	else
		DO=l_do
		RUN=l_run
	fi
	local SDIR=$WORK_ARENA/d$I
	local DDIR=$SDIR
	[ $run_mkfs -eq 1 ] && $DO "rm -rf $SDIR; mkdir $SDIR"
	local DF=$SDIR/m0d.sh
	local DISKS_SH_FILE=$WORK_ARENA/disks$dcf_id.conf
	local STOB_PARAMS="-T linux"
	if [ $STOB == "ad" -o $STOB == "-td" ]; then

		# WORK_ARENA is shared among nodes of Titan/SSU
		# so gen_disks_conf_files() is run only once there
		# to avoid detection of the same disks.
		if ! $DO [ -f $DISKS_SH_FILE ]; then
			local dev_id=1
			if [ $dcf_id -eq 0 ]; then # new Titan/SSU
				# -1 to exclude addb-stob from numbering
				dev_id=$(($I * ($DISKS_SH_NR -1) +1))
			fi
			gen_disks_conf_files $dev_id || return 1
		fi

		if [ $STOB == "ad" ]; then
			$DO cat $DISKS_SH_FILE
		else
			local disk=`$RUN "cat $DISKS_SH_FILE | grep filename"`
			disk=`echo $disk | head -1 | awk '{print $2}'`
			DDIR=/mnt/tdisk$dcf_id
			$DO umount $DDIR >& /dev/null
			$DO mkfs.ext4 -b 4096 -F $disk 2621440 || return 1
			$DO mkdir -p $DDIR
			$DO mount $disk $DDIR || return 1
		fi
		if [ $? -ne 0 ]; then
			echo "ERROR: can't find $DISKS_SH_FILE file"
			echo "Check the status of Titan disks:"
			$DO ~root/gem.sh dumpdrives
			return 1
		fi
		if [ $STOB == "ad" ]; then
			STOB_PARAMS="-T ad -d $DISKS_SH_FILE"
		fi
	fi

	$DO "echo rotated > ${SLOG}$I.log"

	# Generate configuration entries for devices.
	gen_device_conf_ids
	mkiosmddevs ${#SERVICES[*]} $POOL_WIDTH || return 1
	lnet_nid=`sudo lctl list_nids | head -1`
	server_nid=${server_nid:-$lnet_nid}
	#server_id is a global variable and is used inside build_conf() for HA.
	local SNAME
	if [ $I -eq 0 ]; then
		local DIR=$WORK_ARENA/confd
		local multiple_pools=0
		build_conf $NR_DATA $NR_PARITY $POOL_WIDTH $multiple_pools \
			SERVICES[@]  MDSERVICES[@] > $CONF_FILE
		if [ $verbosity -gt 0 ] ;then
			# Just show conf
			cat $CONF_FILE
		fi
		if [ $run_mkfs -eq 1 ]; then
			mkfs $DIR "-T linux" "-c $CONF_FILE" "-e $XPT:$CONFD_EP" || return 1
		fi
		$RUN "cd $DIR && \
M0_TRACE_IMMEDIATE_MASK=$M0D_TRACE_MASK \
M0_TRACE_LEVEL=$M0D_TRACE_LEVEL \
M0_TRACE_PRINT_CONTEXT=$M0D_TRACE_CONTEXT \
$M0D -T linux -D $DIR/db -S $DIR/stobs \
-A linuxstob:$DIR/addb-stobs \
-e $XPT:$CONFD_EP -c $CONF_FILE \
$XPT_SETUP -f $proc_fid_confd" > ${SLOG}-confd.log &
		if [ $? -ne 0 ]; then
			echo ERROR: Failed to start confd server on $H
			return 1
		fi
		sleep 2

		DIR=$WORK_ARENA/ha
		if [ $run_mkfs -eq 1 ]; then
			mkfs $DIR "-T linux" "-c $CONF_FILE" "-e $XPT:$HA_EP" || return 1
		fi
		echo Running m0d...
		$RUN "cd $DIR && \
M0_TRACE_IMMEDIATE_MASK=$M0D_TRACE_MASK \
M0_TRACE_LEVEL=$M0D_TRACE_LEVEL \
M0_TRACE_PRINT_CONTEXT=$M0D_TRACE_CONTEXT \
$M0D -T linux -D $DIR/db -S $DIR/stobs -A linuxstob:$DIR/addb-stobs \
-w $POOL_WIDTH -e $XPT:$HA_EP -c $CONF_FILE \
$XPT_SETUP -f $proc_fid_ha" >> ${SLOG}-ha.log &
		if [ $? -ne 0 ]; then
			echo ERROR: Failed to start m0d on $H
			return 1
		fi
		sleep 2

		DIR=$WORK_ARENA/mds
		if [ $run_mkfs -eq 1 ]; then
			mkfs "$DIR" "-T linux" "-c $CONF_FILE" "-e $XPT:$MDS_EP" || return 1
		fi
		echo Running m0d...
		$RUN "cd $DIR && \
M0_TRACE_IMMEDIATE_MASK=$M0D_TRACE_MASK \
M0_TRACE_LEVEL=$M0D_TRACE_LEVEL \
M0_TRACE_PRINT_CONTEXT=$M0D_TRACE_CONTEXT \
$M0D -T linux -D $DIR/db -S $DIR/stobs -A linuxstob:$DIR/addb-stobs \
-w $POOL_WIDTH -e $XPT:$MDS_EP -H $HA_EP -c $CONF_FILE \
$XPT_SETUP -f $proc_fid_mds" >> ${SLOG}-mds.log &
		if [ $? -ne 0 ]; then
			echo ERROR: Failed to start m0d on $H
			return 1
		fi
		sleep 2
	fi
	SNAME+=" -H $HA_EP -f $proc_fid_ios"

	if [ $run_mkfs -eq 1 ]; then
		mkfs "$DDIR" "$STOB_PARAMS" "-H $HA_EP" "-e $XPT:$EP" || return 1
	fi
	echo Running m0d...
	$RUN "cd $DDIR && \
M0_TRACE_IMMEDIATE_MASK=$M0D_TRACE_MASK \
M0_TRACE_LEVEL=$M0D_TRACE_LEVEL \
M0_TRACE_PRINT_CONTEXT=$M0D_TRACE_CONTEXT \
$M0D $STOB_PARAMS -D $DDIR/db -S $DDIR/stobs -A linuxstob:$DDIR/addb-stobs \
-w $POOL_WIDTH -e $XPT:$EP $SNAME $XPT_SETUP" >> ${SLOG}$I.log &
	if [ $? -ne 0 ]; then
		echo ERROR: Failed to start m0d on $H
		return 1
	fi

	STARTED[$H]=$H
}

function wait_for_services ()
{
	local LOG_FILES="$1"
	local NR=$2

	local log_nr=`echo $LOG_FILES | wc -w`
	if [ $NR -ne $log_nr ]; then
		echo "ERROR: Number of services ($NR) doesn't equal to number of log files ($log_nr)"
		echo "List of the log files: $LOG_FILES"
		return 1
	fi

	while true; do
		local STARTED_NR=`cat $LOG_FILES | grep CTRL | wc -l`
		echo "Started $STARTED_NR (of $NR) services..."
		[ $STARTED_NR -ge $NR ] && break
		local START_ERROR=`cat $LOG_FILES | grep ERROR | wc -l`
		if [ $START_ERROR -gt 0 ]; then
			echo "Failed to start Mero!"
			cat $LOG_FILES | grep ERROR
			return 1
		fi
		l_do sleep 5
	done

	return 0
}

function start_servers ()
{
	local i
	local devs_conf_cnt=0
	if [ $STOB == "ad" -o $STOB == "-td" ]; then
		for ((i=0; i < ${#SERVICES[*]}; i++)); do
			H=${HOSTS[$i]}
			local RUN
			[ $H == $THIS_HOST ] && RUN=l_run || RUN="r_run $H"
			$RUN rm -f $WORK_ARENA/disks*.conf
		done
	fi

	MDS_EP=${SERVICES[0]%:*}:99
	MDSERVICES[0]=$MDS_EP
	CONFD_EP=${SERVICES[0]%:*:*}:33:100
	HA_EP=${SERVICES[0]%:*:*}:34:1

	SLOG=$WORK_ARENA/server
	rm -f ${SLOG}*.log
	for ((i=0; i < ${#SERVICES[*]}; i++)); do
		H=${HOSTS[$i]}
		SEP=${SERVICES[$i]}	# server EP
		# Check for new Titan/SSU
		if [ $i -gt 0 ] && [ ${H%-*} != ${HOSTS[((i-1))]%-*} ]; then
			devs_conf_cnt=0
		fi
		start_server $H $SEP $i $devs_conf_cnt
		if [ $? -ne 0 ]; then
			return 1
		fi
		devs_conf_cnt=`expr $devs_conf_cnt + 1`
	done

	if [ $STOB == "ad" -o $STOB == "-td" ]; then
		echo "Found total $MAX_DISK_ID disks"
		if [ $MAX_DISK_ID -lt $POOL_WIDTH ]; then
			echo "ERROR: Not enough disks found (only $MAX_DISK_ID of $POOL_WIDTH required)!"
			return 1
		fi
	fi

	echo "Wait for the IO services to start up..."
	wait_for_services "${SLOG}[0-9]*.log" $SERVICES_NR || return 1
	echo "Wait for the confd service to start up..."
	wait_for_services "${SLOG}-confd.log" 1 || return 1

	return 0
}

function stop_server ()
{
	local H=$1
	local PATTERN=$2
	local RUN

	echo "stopping servers on host $H"
	if [ $H != $THIS_HOST ]; then
		RUN="r_run $H"
	else
		RUN=l_run
	fi
	$RUN pkill -f "'$PATTERN'"
}

function wait4server ()
{
	local H=$1
	local PATTERN=$2
	echo Wait for servers to finish on host $H
	local RUN
	if [ $H != $THIS_HOST ]; then
		RUN="r_run $H"
	else
		RUN=l_run
	fi
	$RUN 'while [ "`pgrep -f '"'$PATTERN'"'`" ];
	      do echo -n .; sleep 5; done'
	echo
}

function wait4servers ()
{
	local PATTERN=$1
	for H in ${STARTED[*]}; do
		wait4server $H "$PATTERN"
	done
}

function pstop_servers()
{
	local PATTERN=$1
	for H in ${STARTED[*]}; do
		stop_server $H "$PATTERN"
	done
	wait4servers "$PATTERN"
}

function stop_servers()
{
	pstop_servers "m0d.*/d0"
	pstop_servers "m0d.*/confd"
	pstop_servers "m0d.*/mds"
	pstop_servers m0d
}

function setup_loops ()
{
	echo Setting up loop devices ...

	for ((i = 0; i < $((POOL_WIDTH + SERVICES_NR)); i++)); do
		if [ $run_mkfs -eq 1 ]; then
			l_do dd if=/dev/zero of=$WORK_ARENA/disk-image-$i \
				bs=1M seek=1M count=1
		fi
		if [ ! -e /dev/loop$i ]; then
			create_loop_device $i
		fi
		losetup -d /dev/loop$i &> /dev/null
		l_do losetup /dev/loop$i $WORK_ARENA/disk-image-$i
		loop_used=$i
	done
}

function cleanup ()
{
	echo Cleaning up ...
	if [ "x_$IS_MOUNTED" == "x_yes" ]; then
		l_do umount $MP
		if [ $? -ne 0 ]; then
			cat > /dev/stderr << EOF
WARNING! Failed to unmount $MP
         Services won't be stopped.
         You should umount and stop the services manually..
EOF
			return 1
		fi
	fi
	stop_servers || return 1
	teardown_hosts
	for ((i = $loop_used; i >= 0; i--)); do
		losetup -d /dev/loop$i
	done
}

######
# main

setup_services_and_hosts()
{
	local i

        for ((i = 0; i < $((${#HOSTS_SERVICES[*]} / 2)); i++)); do
                HOSTS[$i]=${HOSTS_SERVICES[((i*2))]}
                SERVICES[$i]=${HOSTS_SERVICES[((i*2 +1))]}
        done
}

setup_params()
{
	if [ $setup_local_server_config -eq 1 ]; then
		setup_local_params
	else
		setup_services_and_hosts
	fi

	SERVICES_NR=${#SERVICES[*]}
	POOL_WIDTH=${POOL_WIDTH:-$SERVICES_NR}
	if ((POOL_WIDTH % SERVICES_NR != 0)); then
		echo -n "ERROR: Pool width ($POOL_WIDTH) must be multiple of "
		echo    "services number ($SERVICES_NR)"
		exit 1
	fi

	# number of disks to split by for each service in ad-stob mode
	DISKS_SH_NR=$(expr $POOL_WIDTH / $SERVICES_NR + 1) # +1 for ADDB stob

	NR_PARITY=${NR_PARITY:-1}
	# spare_nr == parity_nr, that's why we multiply on 2
	NR_DATA=${NR_DATA:-$(expr $POOL_WIDTH - $NR_PARITY \* 2)}
}

main()
{
	setup_params

	l_do mkdir -p $WORK_ARENA
	cd $WORK_ARENA

	if [ $setup_loops_p -ne 0 ]; then
		setup_loops
	fi

	LSUM=$(sum $SUMFILE)

	rmmod m0loop m0mero m0gf &> /dev/null

	#ldemo now needs kernel module loaded for some reason...
	l_do $GF_KO_LOAD_CMD || {
		echo ERROR: Failed to load m0gf module
		exit 1
	}
	l_do $MERO_KO_LOAD_CMD || {
		echo ERROR: Failed to load m0mero module
		rmmod m0gf
		exit 1
	}

	local rows=4
	local groups=$((rows * POOL_WIDTH / (NR_DATA + NR_PARITY*2) + 1))
	l_do $M0LAYOUT $NR_DATA $NR_PARITY $POOL_WIDTH $rows $groups
	if [ $? -ne 0 ]; then
		echo ERROR: Parity configuration is incorrect
		exit 1
	fi

	setup_hosts || exit 1
	if [ $client_only -eq 0 ]; then
		start_servers || exit 1
	fi

	# mount the file system
	mkdir -p $MP
	l_do "mount -t m0t1fs -o pfid='$M0T1FS_PROC_ID',profile='$PROF_OPT',ha=$HA_EP,$oostore_mode 'm0t1' $MP" || {
		echo ERROR: Unable to mount the file system
		exit 1
	}
	mount | grep m0t1fs
	IS_MOUNTED=yes
	time df $MP

	# wait to terminate
	if [ $wait_after_mount -eq 1 ]; then

		echo
		echo The mero file system may be accessed with another terminal at $MP
		echo Type quit or EOF in this terminal to unmount the file system and cleanup
		while read LINE; do
			if [ "$LINE" = "quit" ]; then
				break
			fi
		done
		echo
	fi
}

while getopts "$OPTIONS_STRING" OPTION; do
    case "$OPTION" in
        a)
            STOB="ad"
            ;;
        c)
            client_only=1
            ;;
        o)
            oostore_mode=oostore
            ;;
        m)
            run_mkfs=1
            ;;
        l)
            use_loop_device=1
            ;;
        s)
            setup_loops_p=1
            ;;
        L)
            setup_local_server_config=1
            ;;
        n)
            SERVICES_NR="$OPTARG"
            ;;
        d)
            NR_DATA="$OPTARG"
            ;;
        k)
            NR_PARITY="$OPTARG"
            ;;
	p)
            POOL_WIDTH="$OPTARG"
            ;;
        u)
            echo "
Err: unit size is set per file with \`setfattr -n lid -v <N> <file>' cmd"
            echo
            usage
            exit 1
            ;;
        q)
            wait_after_mount=0
            ;;
        v)
            verbosity=$(($verbosity + 1))
            ;;
        h)
            usage
            exit 0
            ;;
        *)
            usage
            exit 1
            ;;
    esac
done

#set -x

trap cleanup EXIT

main

# Local variables:
# sh-basic-offset: 8
# sh-indentation: 8
# tab-width: 8
# End:
