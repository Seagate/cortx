#!/usr/bin/env perl

# COPYRIGHT 2016 XYRATEX TECHNOLOGY LIMITED
#
# THIS DRAWING/DOCUMENT, ITS SPECIFICATIONS, AND THE DATA CONTAINED
# HEREIN, ARE THE EXCLUSIVE PROPERTY OF XYRATEX TECHNOLOGY
# LIMITED, ISSUED IN STRICT CONFIDENCE AND SHALL NOT, WITHOUT
# THE PRIOR WRITTEN PERMISSION OF XYRATEX TECHNOLOGY LIMITED,
# BE REPRODUCED, COPIED, OR DISCLOSED TO A THIRD PARTY, OR
# USED FOR ANY PURPOSE WHATSOEVER, OR STORED IN A RETRIEVAL SYSTEM
# EXCEPT AS ALLOWED BY THE TERMS OF XYRATEX LICENSES AND AGREEMENTS.
#
# YOU SHOULD HAVE RECEIVED A COPY OF XYRATEX'S LICENSE ALONG WITH
# THIS RELEASE. IF NOT PLEASE CONTACT A XYRATEX REPRESENTATIVE
# http://www.xyratex.com/contact
#
# Original author: Dmitriy Chumak <dmitriy_chumak@xyratex.com>
# Original creation date: 28-Dec-2012


# This utility displays Mero trace log in a human-friendly format, including
# filtering log entries by various parameters, like log level, subsystem, file,
# func name, etc.
#
# For detailed description and usage information please refer to the POD
# documentation at the end of file, after the __END__ marker.


# enable all features of Modern Perl, almost the same as done by Modern::Perl
# module, but doesn't require it as a dependency
use 5.010;
use strict;
use warnings;
use autodie;
use feature ':5.16';  # target minimum Perl version provided by the base distribution


# check that all required external modules are available and display a hint to
# the user about how they can be installed using default package management
# system, if they are missing
BEGIN {

    my @required_modules = (
        {
            name       => 'YAML::XS',
            debian_pkg => 'libyaml-libyaml-perl',
            redhat_pkg => 'perl-YAML-LibYAML'
        },
        {
            name       => 'DateTime',
            debian_pkg => 'libdatetime-perl',
            redhat_pkg => 'perl-DateTime'
        },
        {
            name       => 'File::Which',
            debian_pkg => 'libfile-which-perl',
            redhat_pkg => 'perl-File-Which'
        },
        {
            name       => 'List::MoreUtils',
            debian_pkg => 'liblist-moreutils-perl',
            redhat_pkg => 'perl-List-MoreUtils'
        },
        {
            name       => 'Try::Tiny',
            debian_pkg => 'libtry-tiny-perl',
            redhat_pkg => 'perl-Try-Tiny'
        },
        {
            name       => 'MCE',
            debian_pkg => 'libmce-perl',
            redhat_pkg => 'perl-MCE'
        },
        {
            name       => 'Sereal',
            debian_pkg => 'libsereal-encoder-perl and libsereal-decoder-perl',
            redhat_pkg => 'perl-Sereal'
        },
    );
    my $some_module_is_missing = 0;

    for my $m (@required_modules) {

        my $module = $m->{name};

        $module =~ s#::#/#g;
        $module .= '.pm';

        no warnings 'uninitialized';
        if (eval { require $module; 1; } ne 1) {
            use warnings 'uninitialized';
            $some_module_is_missing = 1;
            print "$m->{name} perl module is missing\n"
                  . "   It can be installed manually or using package management system:\n"
                  . "     debian based:  apt-get install $m->{debian_pkg}\n"
                  . "     red-hat based: yum install $m->{redhat_pkg}\n"
                  . "     manually:      cpanm $m->{name}\n\n";
        }
    }

    die "Please, install all required modules\n"
        if $some_module_is_missing;
}


package Tie::Array::Lazy::YAMLstream;
{
    use base qw( Tie::Array );

    use Carp;
    use Try::Tiny;
    use English qw( -no_match_vars ); # avoids regex performance penalty
    use POSIX qw( INT_MAX );
    #use Data::Dumper;

    our $VERSION = '1.002001';
    $VERSION = eval $VERSION;


    sub TIEARRAY
    {
        my $class = shift;
        my $file  = shift;

        open my $stream, "$file";

        my $self = {
            stream        => $stream,
            current_index => 0,
        };

        if (not eof $self->{stream}) {
            local $INPUT_RECORD_SEPARATOR = '---';
            my $doc = readline $self->{stream};
            chomp $doc;

            try {
                $self->{current} = YAML::XS::Load( $doc );
            }
            catch {
                carp "malformed YAML data: $_";
            };
        }

        return bless $self, $class;;
    }

    sub DESTROY
    {
        my $self = shift;

        close $self->{stream};
    }

    sub FETCH
    {
        my $self  = shift;
        my $index = shift;


        if ($self->{current_index} == $index) {

            croak "Internal error in package " . __PACKAGE__ . " - no current"
                  . " element for index $index\n"
                if !exists $self->{current};

            return $self->{current};
        }
        else {
            $self->{current_index} = $index;
        }

        while (not eof $self->{stream}) {
            local $INPUT_RECORD_SEPARATOR = "---\n";
            my $doc = readline $self->{stream};
            chomp $doc;

            try {
                $self->{current} = YAML::XS::Load( $doc );
            }
            catch {
                my ($doc_without_msg) = $doc =~ /^(.*)(?=msg:)/xms;
                carp "malformed YAML data: $_\n"
                     . "guilty trace record:\n$doc_without_msg";
                $self->{current} = undef;
            };

            return $self->{current}
                if defined $self->{current};
        }

        return;
    }

    sub FETCHSIZE
    {
        my $self = shift;

        return defined $self->{current} ? INT_MAX : 0;
    }
}


package main;

# core modules
use Carp;
use English qw( -no_match_vars ); # avoids regex performance penalty
use Getopt::Long qw( :config no_ignore_case bundling );
use Pod::Usage;
use IO::Handle;
use Term::ANSIColor;
use File::Temp qw( tempfile );
use File::Spec;
use File::Copy;
use List::Util qw( max );

# external modules (not included into base perl distribution)
use YAML::XS;
use DateTime;
use File::Which;
use List::MoreUtils qw( any none );
use Try::Tiny;
use Sereal qw( sereal_encode_with_object sereal_decode_with_object );
use Sereal::Encoder qw( SRL_SNAPPY );
use MCE;
use MCE::Candy;

# debugging
#use Data::Dumper;


# global variables
my %cli_option = (
    input_file      => '-', # STDIN by default
    output_file     => '-', # STDOUT by default
    stream_mode     => 1,
    use_pager       => 1,
    flush_output    => 0,
    mce_workers     => MCE::Util::get_ncpu() > 1 ? MCE::Util::get_ncpu() : 0,
    log_dir         => '/var/log/mero',
    mero_dir        => '/var/mero',
    color           => 'auto',
    format          => 'med',
    level           => 'call+',
    subsys          => 'all',
    relpath         => 1,
    column_width    => 50,
    stackaddr_width => 7,
    stackaddr_hl    => 2,
    func            => undef, # all funcs
);

my %level = (
    'call'    => qr/ ^ CALL $ /xms,
    'debug'   => qr/ ^ DEBUG $ /xms,
    'info'    => qr/ ^ INFO $ /xms,
    'notice'  => qr/ ^ NOTICE $ /xms,
    'warn'    => qr/ ^ WARN $ /xms,
    'error'   => qr/ ^ ERROR $ /xms,
    'fatal'   => qr/ ^ FATAL $ /xms,
    'always'  => qr/ ^ ALWAYS $ /xms,
    'call+'   => qr/ ^ CALL   | DEBUG  | INFO   | NOTICE | WARN  | ERROR | FATAL | ALWAYS $ /xms,
    'debug+'  => qr/ ^ DEBUG  | INFO   | NOTICE | WARN   | ERROR | FATAL | ALWAYS $ /xms,
    'info+'   => qr/ ^ INFO   | NOTICE | WARN   | ERROR  | FATAL | ALWAYS $ /xms,
    'notice+' => qr/ ^ NOTICE | WARN   | ERROR  | FATAL  | ALWAYS $ /xms,
    'warn+'   => qr/ ^ WARN   | ERROR  | FATAL  | ALWAYS $ /xms,
    'error+'  => qr/ ^ ERROR  | FATAL  | ALWAYS $ /xms,
    'fatal+'  => qr/ ^ FATAL  | ALWAYS $ /xms,
    'always+' => qr/ ^ ALWAYS $ /xms,
);

my $kernel_trace_records_file = '/sys/kernel/debug/mero/trace/records';
my $kernel_trace_buffer_file  = '/sys/kernel/debug/mero/trace/buffer';
my $kernel_module_core_file   = '/sys/kernel/debug/mero/core';

sub validate_trace_record
{
    my $tr = shift;

    my @required_fields = qw(
        record_num timestamp pid stack_addr subsystem level func file line msg
    );

    for my $field (@required_fields) {
        die "Incorrect format of input data: trace record doesn't have required"
            . " field '$field' or it's empty\n"
            if !exists $tr->{$field} || !defined $tr->{$field};
    }
}

sub validate_format
{
    my $format = shift;

    my @allowed_format_values = qw( short med full custom:<string> );

    die "Incorrect value '$cli_option{format}' of configuration option"
        . " -f|--format, allowed values are: @allowed_format_values\n"
        if $format !~ / (?: ^ short | med | full $ ) | ^custom: /xms;
}

sub validate_level
{
    my $level  = shift;

    my @allowed_levels = qw( call debug info notice warn error fatal always );
    my $level_token = join '|', @allowed_levels;

    $level_token = qr/ \b (?: $level_token ) \b \+? /ixms;

    die "Invalid value of -L|--level option: '$level', it should be in form"
        . " of 'level[+][,level[+]]', where 'level' is one of: @allowed_levels\n"
        if $level !~ / ^ $level_token (?: ,$level_token )* $ /xms;
}

sub validate_subsys
{
    my $subsys  = shift;

    my @allowed_subsys = sort qw(
        all
        addb     extmap     m0d     sns
        adstob   fd         m0t1fs  snscm
        balloc   file       mds     spiel
        be       fol        memory  sss
        btree    fop        mgmt    stats
        cas      formation  net     stob
        cm       ha         other   ut
        cob      ioservice  pool    xcode
        conf     layout     rm
        console  lib        rpc
        dtm      lnet       sm
    );
    my $subsys_token = join '|', @allowed_subsys;

    $subsys_token = qr/ \b (?: $subsys_token ) \b /ixms;

    die "Invalid value of -s|--subsys option: '$subsys', it should be in form"
        . " of '[!]subsys[,subsys]', where 'subsys' is one of: @allowed_subsys\n"
        if $subsys !~ / ^ !? $subsys_token (?: ,$subsys_token )* $ /xms;
}

sub match_level
{
    my $tr = shift;

    if ( !exists $level{ lc $tr->{level} } ) {
        warn "Invalid trace record level '$tr->{level}', record skipped\n";
        return 0;
    }

    return any { $tr->{level} =~ / $level{$_} /ixms }
               split( /,/, $cli_option{level} );
}

sub is_error_level
{
    my $tr = shift;
    my $err_lvl = shift;

    return $tr->{level} =~ / $level{$err_lvl} /ixms;
}

sub match_subsys
{
    my $tr = shift;

    if ( $cli_option{subsys} =~ / ^! /xms ) {
        return none { uc $tr->{subsystem} eq uc $_ }
                    split( /,/, substr($cli_option{subsys}, 1) );
    } else {
        return lc $cli_option{subsys} eq 'all'
               || any { uc $tr->{subsystem} eq uc $_ }
                      split( /,/, $cli_option{subsys} );
    }
}

sub match_file
{
    my $tr = shift;

    return 1
        if !defined $cli_option{file};

    return $tr->{file} =~ /$cli_option{file}/ms;
}

sub match_func
{
    my $tr = shift;

    return 1
        if !defined $cli_option{func};

    return $tr->{func} =~ /$cli_option{func}/ms;
}

sub match_msg
{
    my $tr = shift;

    return 1
        if !defined $cli_option{msg};

    my $highlighted_msg = ( $tr->{msg}
        =~ s/($cli_option{msg})/color('red') . $1 . color('bright_white')/grems );

    return $tr->{msg} =~ /$cli_option{msg}/ms && ($tr->{msg} = $highlighted_msg);
}

sub level_color
{
    my $tr = shift;

    my $level = $tr->{level};
    my %level_color;

    %level_color = (
        CALL    => 'white',
        DEBUG   => 'cyan',
        INFO    => 'green',
        NOTICE  => 'bold blue',
        WARN    => $Term::ANSIColor::VERSION < 3.00 ? 'bold yellow' : 'bright_yellow',
        ERROR   => $Term::ANSIColor::VERSION < 3.00 ? 'red'         : 'bright_red',
        FATAL   => 'bold red',
        ALWAYS  => 'magenta',
    );

    die "Invalid value '$level' of trace record field 'level'\n"
        if !exists $level_color{$level};

    return $level_color{$level};
}

my @color_map = qw(
    red         green        yellow        blue        magenta        cyan white
    bright_red  bright_green bright_yellow bright_blue bright_magenta
    bright_cyan bright_white
);


sub time_of
{
    my $tr = shift;

    state %color;
    state $next_color = 2;

    # TODO: currently, libmero stores time as rdtsc(), consider changing to
    # something meaning, like epoch or other with more precision
    #my $dt   = DateTime->from_epoch( epoch => $tr->{timestamp} );
    #my $time = $dt->month_abbr . '-' . $dt->day . ' ' . $dt->hms . '.'
               #. $dt->nanosecond . ' ';
    #return $time;

    my $rdtsc = $tr->{timestamp};
    if (defined $ENV{ANSI_COLORS_DISABLED} and $ENV{ANSI_COLORS_DISABLED} == 1) {
        $rdtsc = substr($rdtsc, 0, (length $rdtsc) - 9) . '.'
                 . substr($rdtsc, -9, 3) . '.' . substr($rdtsc, -6);
    }
    else {
        my $base = substr($rdtsc, -9, 3);
        if (not exists $color{$base}) {
            $color{$base} = $next_color++;
            if ($next_color > $#color_map) {
                $next_color = 0;
            }
        }
        $rdtsc = substr($rdtsc, 0, (length $rdtsc) - 9) . '.'
                 . color( $color_map[ $color{$base} ] ) . $base
                 . color( level_color($tr) ) . '.' . substr($rdtsc, -6);
    }

    return $rdtsc;
}

my $format_placeholder = qr/
                             %[
                                n # \n
                                t # \t
                                N # record_Num
                                T # Timestamp
                                p # pid
                                a # stack_Addr
                                s # Subsystem
                                l # Level
                                f # Func
                                F # File
                                L # Line
                                m # Msg
                              ]
                           /xms;

sub expand_format_placeholder
{
    my $placeholder = shift;
    my $tr          = shift;

    die "Invalid format placeholder '$placeholder' for custom format option\n"
        if $placeholder !~ m/^$format_placeholder$/xms;

    given ($placeholder) {
        when ('%n') {
            return "\n";
        }
        when ('%t') {
            return "\t";
        }
        when ('%N') {
            return "$tr->{record_num}";
        }
        when ('%T') {
            return time_of($tr);
        }
        when ('%p') {
            return "$tr->{pid}";
        }
        when ('%a') {
            return "$tr->{stack_addr}";
        }
        when ('%s') {
            return "$tr->{subsystem}";
        }
        when ('%l') {
            return "$tr->{level}";
        }
        when ('%f') {
            return "$tr->{func}";
        }
        when ('%F') {
            return file_of($tr);
        }
        when ('%L') {
            return "$tr->{line}";
        }
        when ('%m') {
            return "$tr->{msg}";
        }
    };

    return;
}

sub stack_addr_of
{
    my $trace_record = shift;

    state %color;
    state $next_color = 0;

    if (defined $ENV{ANSI_COLORS_DISABLED} and $ENV{ANSI_COLORS_DISABLED} == 1) {
        return $trace_record->{stack_addr};
    }
    else {
        my $addr = substr $trace_record->{stack_addr}, -$cli_option{stackaddr_width};
        my ($base, $offset) = ( substr($addr, 0, $cli_option{stackaddr_hl})
                                , substr($addr, $cli_option{stackaddr_hl}) );

        if (! exists $color{$base}) {
            $color{$base} = $next_color++;
            if ($next_color > $#color_map) {
                $next_color = 0;
            }
        }

        return color( $color_map[$color{$base}] ) . $base
               . color( level_color($trace_record) ) . $offset;
    }
}

sub file_of
{
    my $trace_record = shift;

    my ($relpath) = $trace_record->{file}
        =~ m#^[/.].*/?mero(?:-(?:\d|\w)(?:\.(?:\d|\w)){2,5})?/(.*)#xms;
    $relpath = defined $relpath ? $relpath : $trace_record->{file};
    return $cli_option{relpath} ? $relpath : $trace_record->{file};
}

sub file_line_func_of
{
    my $trace_record = shift;

    my $flf = file_of($trace_record) . ':' . $trace_record->{line} . ':'
              . $trace_record->{func};
    return $flf . ' ' x max(1, $cli_option{column_width} - length $flf)
}

sub func_of
{
    my $trace_record = shift;

    return $trace_record->{func} . ' ' x (30 - length $trace_record->{func})
}

sub format_trace_record
{
    my $tr  = shift;

    my $buf;

    given ($cli_option{format}) {

        when ('short') {
            $buf = color( level_color($tr) )
                   . sprintf('%6s  ',       $tr->{level})
                   . "[" . file_of($tr) . ":$tr->{line}:$tr->{func}]  "
                   . "$tr->{msg}"
                   . color('reset')
                   . "\n";
        }

        when ('med') {
            $buf = color( level_color($tr) )
                   . sprintf('%-4u  ',  $tr->{record_num})
                   . sprintf('%-8s  ',  time_of($tr))
                   . sprintf('%s  ',    stack_addr_of($tr))
                   . sprintf('%-6s  ',  $tr->{level})
                   . sprintf('%s  ',    file_line_func_of($tr))
                   . color('bright_white') . "$tr->{msg}"
                   . color('reset')
                   . "\n";
        }

        when ('full') {
            $buf = color( level_color($tr) )
                   . sprintf('%-7u  ',  $tr->{record_num})
                   . sprintf('%-18s  ', time_of($tr))
                   . sprintf('%-6s  ',  $tr->{level})
                   . sprintf('%-10s  ', $tr->{subsystem})
                   . sprintf('%-6s  ',  $tr->{pid})
                   . "$tr->{stack_addr}  "
                   . "$tr->{func}  "
                   . file_of($tr) . ":$tr->{line}"
                   . color('reset')
                   . "\n"
                   . color( level_color($tr) )
                   . "    $tr->{msg}"
                   . color('reset')
                   . "\n\n";
        }

        when (/^custom:/xms) {
            my ($format) = $cli_option{format} =~ m/^custom:(.*)$/xms;

            $format =~ s/
                          ($format_placeholder)
                        /
                          expand_format_placeholder($1, $tr)
                        /egxms;

            $buf = color( level_color($tr) ) . $format . color('reset') . "\n";
        }

        default {
            my @allowed_format_values = qw( short med full custom:<string> );
            die "Incorrect value '$cli_option{format}' of configuration option"
                . " -f|--format, allowed values are: @allowed_format_values\n";
        }
    }

    return $buf;
}

sub locate_m0_binary
{
    my $binary_name       = shift;
    my $skip_if_not_found = shift;

    my $binary_path;
    my (undef, undef, $basename) = File::Spec->splitpath( $PROGRAM_NAME );

    # check whether we are running from source tree
    if ( $PROGRAM_NAME =~ m#
                             (?: utils/(?:trace/)? | ^./(?:trace/)? )
                             $basename $
                           #xms )
    {
        ($binary_path = $PROGRAM_NAME) =~ s# $basename $ #$binary_name#xms;

        if ( ! -x $binary_path ) {
            $binary_path =~ s# /trace(?=/) ##xms;

            if ( ! -x $binary_path ) {
                $binary_path = which($binary_name);
            }
        }
    }
    else
    {
        $binary_path = which($binary_name);
    }

    if ( $cli_option{use_usrbin_binary} ) {
        $binary_path = "/usr/bin/$binary_name";
    }

    return $binary_name
        if (!defined $binary_path or ! -x $binary_path)
            and defined $skip_if_not_found;

    die "Failed to find '$binary_name' utility in PATH or in the development"
        . " tree next to ourselves\n"
        if !defined $binary_path;

    die "Can't use $binary_path: no such file or it's not an executable\n"
        if ! -x $binary_path;

    return $binary_path;
}

sub create_tempfile_for
{
    my $file_name = shift;
    my $suffix    = shift // '.yml';

    my (undef, undef, $basename)
        = File::Spec->splitpath( $file_name );

    my $temp_file = File::Temp->new(TEMPLATE => 'm0trace-' . $basename . '-XXXXX',
                                    SUFFIX   => $suffix,
                                    UNLINK   => 1);

    return $temp_file;
}

sub prepare_input_file
{
    my $input_file;

    if ( $cli_option{input_file} eq '-' # assume that STDIN is always ASCII
         or $cli_option{input_file} =~ m/ \. (?: yml | yaml | log ) $ /xms
         or $cli_option{input_file} eq $kernel_trace_records_file
         or -T $cli_option{input_file} )
    {
        $input_file = "<$cli_option{input_file}";
    }
    elsif ( $cli_option{input_file} # compressed log files like *.yml.gz
                =~ m/ \. (?: yml|yaml|log) \. (?<ztype> gz|bz2|xz) $ /xms )
    {
        given ( $+{ztype} ) {
            when ('gz') {
                $input_file = "gunzip -c $cli_option{input_file} |";
            }
            when ('bz2') {
                $input_file = "bunzip2 -c $cli_option{input_file} |";
            }
            when ('xz') {
                $input_file = "xz -d -c $cli_option{input_file} |";
            }
        }
    }
    else # input file is in binary format
    {
        # if it's a kerner crash dump it requires preprocessing by C<m0kdump2trace>
        if ($cli_option{kdump}) {
            my $m0kdump2trace = locate_m0_binary('m0kdump2trace');

            my $module_img = create_tempfile_for( $cli_option{input_file}, '.modcore' );
            system "$m0kdump2trace -f -m $cli_option{input_file} $module_img";

            my $trace_buf = create_tempfile_for( $cli_option{input_file}, '.tracebuf' );
            system "$m0kdump2trace -f $cli_option{input_file} $trace_buf";

            $cli_option{input_file}   = $trace_buf;
            $cli_option{module_image} = $module_img;
        }

        my $m0ut        = locate_m0_binary('m0ut', 'skip-if-not-found');
        my $m0traced    = locate_m0_binary('m0traced');
        my $m0tracedump = locate_m0_binary('m0tracedump');
        my $dump_opt    = defined $cli_option{module_image}
                              ? "-k $cli_option{module_image}" : '';

        if ($cli_option{dump_header}) {
            $input_file = "$m0tracedump -H -i $cli_option{input_file} |";
        }
        elsif ($cli_option{follow}) {
            $input_file = "$m0traced -p -S -i $cli_option{input_file} "
                          . "| $m0tracedump -s $dump_opt |";
        }
        elsif ($cli_option{stream_mode}) {
            $input_file = $cli_option{input_file} =~ m#m0ut/m0trace#xms ?
                              "$m0ut -T < $cli_option{input_file} |"
                            : "$m0tracedump -s $dump_opt -i $cli_option{input_file} |";
        }
        else {
            my $temp_file = create_tempfile_for( $cli_option{input_file} );

            system "$m0tracedump -S $dump_opt -i $cli_option{input_file} -o $temp_file";
            $input_file = $temp_file;
        }
    }

    return $input_file;
}


sub usage
{
    pod2usage(-verbose => 0);
}

sub help
{
    pod2usage(-verbose => 1);
}

sub man
{
    pod2usage(-verbose => 2);
}

sub process_cli_options
{
    usage() if !GetOptions(
        'i|input=s'            =>  \$cli_option{input_file},
        'o|output=s'           =>  \$cli_option{output_file},
        'S|stream-mode!'       =>  \$cli_option{stream_mode},
        'Y|yaml-output'        =>  \$cli_option{yaml_output},
        'W|workers=i'          =>  \$cli_option{mce_workers},
        'pager!'               =>  \$cli_option{use_pager},
        'flush-output'         =>  \$cli_option{flush_output},
        'color=s'              =>  \$cli_option{color},
        'c'                    =>  sub { $cli_option{color} = 'always' },
        'C'                    =>  sub { $cli_option{color} = 'never' },
        'd'                    =>  \$cli_option{use_usrbin_binary},
        'k|kdump'              =>  \$cli_option{kdump},
        'I|module-image=s'     =>  \$cli_option{module_image},
        'L|log-dir'            =>  \$cli_option{log_dir},
        'H|dump-header'        =>  \$cli_option{dump_header},
        'F|follow'             =>  \$cli_option{follow},
        'M|match-only'         =>  \$cli_option{match_only},
        'r|relpath!'           =>  \$cli_option{relpath},
        'w|column-width=i'     =>  \$cli_option{column_width},
        'a|stackaddr-width=i'  =>  \$cli_option{stackaddr_width},
        'A|stackaddr-hl=i'     =>  \$cli_option{stackaddr_hl},
        'f|format=s'           =>  \$cli_option{format},
        'l|level=s'            =>  \$cli_option{level},
        's|subsys=s'           =>  \$cli_option{subsys},
        'e|file=s'             =>  \$cli_option{file},
        'u|func=s'             =>  \$cli_option{func},
        'm|msg=s'              =>  \$cli_option{msg},

        'h|help'    =>  \&help,
        'usage'     =>  \&usage,
        'man'       =>  \&man
    );

    if ($cli_option{color} eq 'auto'
        and ($cli_option{output_file} ne '-' or ! -t STDOUT)
        or $cli_option{color} eq 'never')
    {
        $ENV{ANSI_COLORS_DISABLED} = 1;
    }

    if ($cli_option{dump_header}) {
        $cli_option{use_pager}   = 0;
        $cli_option{mce_workers} = 0;
    }

    if ($cli_option{follow}) {
        $cli_option{stream_mode}  = 1;
        $cli_option{flush_output} = 1;
        $cli_option{use_pager}    = 0;
    }

    if ($cli_option{flush_output} or !$cli_option{stream_mode}) {
        $cli_option{mce_workers} = 0;
    }

    if ($cli_option{mce_workers}) {
        $cli_option{stream_mode} = 1;
    }

    die "Option '-W|--workers' can't be a negative number or greater than"
        . " 10xCPU cores in the system\n"
        if $cli_option{mce_workers} > MCE::Util::get_ncpu() * 10
           or $cli_option{mce_workers} < 0;

    die "Option '-A|--stackaddr-hl' value ($cli_option{stackaddr_hl})"
        . " can't be greater than value of '-a|--stackaddr-width' option"
        . " ($cli_option{stackaddr_width})\n"
        if ($cli_option{stackaddr_hl} > $cli_option{stackaddr_width});

    validate_format( $cli_option{format} );
    validate_level( $cli_option{level} );
    validate_subsys( $cli_option{subsys} );

    # handle arguments
    if (defined $ARGV[0] and $cli_option{input_file} eq '-') {
        my $file_pattern;

        die "Error: -F|--follow option is allowed only for '*-buf' targets\n"
            if $cli_option{follow} && $ARGV[0] !~ m/-buf$/xms;

        given ($ARGV[0]) {
            when ('kernel') {
                $file_pattern = "trace-m0mero~*.bin";
            }
            when ('kernel-buf') {
                my $module_img = create_tempfile_for('m0mero.ko', '.img');
                copy($kernel_module_core_file, $module_img);

                $cli_option{module_image} = $module_img;
                $cli_option{input_file}   = $kernel_trace_buffer_file;

                return;
            }
            when ('kernel-live') {
                $cli_option{input_file}   = $kernel_trace_records_file;
                $cli_option{use_pager}    = 0;
                $cli_option{flush_output} = 1;
                $cli_option{mce_workers}  = 0;
                return;
            }
            when (/^(?:confd|ha|(?:mds|ios)\d*)$/)   {
                $file_pattern = "trace-m0d-$ARGV[0]-*.bin";
            }
            when (/^m0d[-@][:x[:xdigit:]]+$/)   {
                $file_pattern = "trace-$ARGV[0]-*.bin";
            }
            when (/^(?:confd|ha|(?:rms|mds|ios)\d*|m0d[-@][:x[:xdigit:]]+)-buf$/) {
                $file_pattern = "m0trace.*";
                $ARGV[0] =~ m/^(?<sname>.*)-buf$/xms;
                $cli_option{log_dir} = "$cli_option{mero_dir}/$+{sname}";
            }
            when (/^(?:m0)?ut$/) {
                $file_pattern = "m0trace.*";
                $cli_option{log_dir} = '/var/mero/m0ut';
            }
            default {
                die "Unknown type of requested trace log: '$ARGV[0]',"
                    . " supported values should match pattern:"
                    . " '<kernel|confd|ha|rms*|mds*|ios*|m0d@*>[-buf]',"
                    . " for example 'confd', 'mds-buf', 'ios2', 'ios2-buf'\n";
            }
        }

        die "Log directory '$cli_option{log_dir}' doesn't exist\n"
            if ! -d $cli_option{log_dir};

        $cli_option{input_file}
            = qx(bash -c 'ls -1t $cli_option{log_dir}/$file_pattern 2>/dev/null | head -n1');

        die "No trace logs found for '$ARGV[0]' in $cli_option{log_dir}\n"
            if !$cli_option{input_file};

        chomp $cli_option{input_file};
    }

    return;
}

sub process_records
{
    my $trace_records = shift;
    my $output_fh     = shift;

    READ_RECORDS:
    for my $tr (@{ $trace_records }) {
        last READ_RECORDS
        if !defined $tr;

        validate_trace_record($tr);

        # dereference msg's value if it's formatted as a "!str |" YAML tag
        if (ref $tr->{msg}) {
            $tr->{msg} = ${ $tr->{msg} };
            chomp $tr->{msg};
        }

        if ((match_level($tr) and match_subsys($tr) and match_file($tr)
                    and match_func($tr) and match_msg($tr))
                or (!defined($cli_option{match_only}) and is_error_level($tr, 'warn+')))
        {
            print {$output_fh} format_trace_record($tr);
        }
    }

    return;
}

sub process_records_multicore
{
    my $input_file = shift;
    my $output_fh  = shift;

    my $enc = Sereal::Encoder->new({ compress => SRL_SNAPPY });
    my $dec = Sereal::Decoder->new();

    my $mce = MCE->new(
        max_workers => $cli_option{mce_workers},
        chunk_size  => 1024,
        gather      => MCE::Candy::out_iter_fh($output_fh),
        freeze      => sub { return sereal_encode_with_object($enc, $_[0]) },
        thaw        => sub { return sereal_decode_with_object($dec, $_[0]) },
    );

    open my $input_stream, "$input_file";
    local $INPUT_RECORD_SEPARATOR = "\n---";

    $mce->forchunk($input_stream, sub {
        my ($mce, $chunk_ref, $chunk_id) = @_;
        my @records;

        PROCESS_RECORDS:
        for my $tr_doc (@{ $chunk_ref }) {
            $mce->next()
                if !defined $tr_doc;

            chomp $tr_doc;

            my $tr;

            try {
                $tr = YAML::XS::Load( $tr_doc );
            }
            catch {
                my ($doc_without_msg) = $tr_doc =~ /^(.*)(?=msg:)/xms;
                carp "malformed YAML data: $_\n"
                     . "guilty trace record:\n$doc_without_msg";
                $tr = undef;
            };

            next PROCESS_RECORDS
                if !defined $tr;

            validate_trace_record($tr);

            # dereference msg's value if it's formatted as a "!str |" YAML tag
            if (ref $tr->{msg}) {
                $tr->{msg} = ${ $tr->{msg} };
                local $INPUT_RECORD_SEPARATOR = "\n";
                chomp $tr->{msg};
            }

            if ((match_level($tr) and match_subsys($tr) and match_file($tr)
                 and match_func($tr) and match_msg($tr))
                or (!defined($cli_option{match_only}) and is_error_level($tr, 'warn+')))
            {
                push @records, format_trace_record($tr);
            }
        }

        $mce->gather($mce->chunk_id, @records);
    });

    close $input_stream;

    return;
}

sub main
{
    process_cli_options();

    my $input_file = prepare_input_file();

    my @trace_records;

    if ($cli_option{stream_mode}) {
        if ($cli_option{mce_workers} == 0) {
            tie @trace_records, 'Tie::Array::Lazy::YAMLstream', $input_file;
        }
    }
    elsif (!$cli_option{dump_header}) {
        my $yaml_data = YAML::XS::LoadFile( $input_file );

        die "Incorrect format of input data: root entry 'trace_records' not found\n"
            if !exists $yaml_data->{trace_records};

        die "No trace records available\n"
            if !defined $yaml_data->{trace_records};

        @trace_records = @{ $yaml_data->{trace_records} }
    }

    my $output_fh;

    if ($cli_option{output_file} eq '-' and $cli_option{use_pager}) {
        open $output_fh, "| less -RSM";
    }
    else {
        open $output_fh, ">$cli_option{output_file}";
    }

    if ($cli_option{flush_output}) {
        $output_fh->autoflush(1);
    }

    if ($cli_option{yaml_output}
        or $cli_option{dump_header} and !$cli_option{stream_mode})
    {
        open my $input_fh, "$input_file";
        copy($input_fh, $output_fh);
        close $input_fh;
    }
    elsif ($cli_option{dump_header}) {
        print {$output_fh} YAML::XS::Dump( $trace_records[0]->{header} );
    }
    elsif ($cli_option{mce_workers} > 0) {
        process_records_multicore($input_file, $output_fh);
    }
    else {
        process_records(\@trace_records, $output_fh);
    }

    close $output_fh;

    return;
}

main();


__END__

=head1 NAME

m0trace - display Mero trace logs in a human-friendly format

=head1 SYNOPSIS

m0trace  kernel[-buf] | ha[-buf] | confd[-buf] | iosX[-buf] | mdsX[-buf]

m0trace  [-i|--input IFILE] [-o|--output OFILE]
         [-Y|--yaml-output] [-W|--workers NUM] [--no-pager]
         [--no-relpath] [-w|--column-width NUM] [-c|-C|--color MODE] [-d]
         [-k|--kdump] [--flush-output] [-I|--module-image FILE] [-L|--log-dir DIR]
         [-H|--dump-header] [-F|--follow] [-M|--match-only] [-f|--format FMT]
         [-a|--stackaddr-width] [-A|--stackaddr-hl] [-l|--level LVL]
         [-s|--subsys SBS] [-e|--file FL] [-u|--func FUN] [-m|--msg MSG]
         [-h|--help] [--usage] [--man]

=head1 DESCRIPTION

This utility displays Mero trace log in a human-friendly format, including
filtering log entries by various parameters, like log level, subsystem, file,
func name, etc.

It reads trace log data from STDIN or from file, in binary or in YAML format,
see B<-i|--input> option.

=head1 ARGUMENTS

A Mero service name can be provided as an optional argument, like I<kernel>,
I<confd>, I<ha>, I<mds>, I<ios> or I<m0d@FID>. If specified, C<m0trace> will
automatically pick the latest trace file for that service. Additionally to that,
a service name can be followed by C<-buf> suffix, in that case C<m0trace> will
use the I<mmaped> trace buffer of C<m0d> process directly (a so-called
C<m0trace.PID> file).

=head1 OPTIONS

=over 8

=item B<-i|--input=I<ifile>>

Input file name, if omitted then STDIN is used by default. If input comes from
STDIN or input file has C<*.yml>, C<*.yaml> or C<*.log> extension, then it's
assumed to be a text file in YAML format (C<m0trace> recognizes compressed YAML
logs if file has C<*.gz>, C<*.bz2> or C<*.xz> extension). Otherwise it is
assumed to be a raw binary trace data and in that case it is converted into
YAML format by piping through B<m0tracedump> utility.

=item B<-o|--output=I<ofile>>

Output file name, if omitted then STDOUT is used by default.

=item B<--no-stream-mode>

By default, B<m0trace> expects that each trace record in log file is represented
as a separate YAML document, which allows to read them one by one and
display/filter results immediately. With this option, C<m0trace> treats trace log
as a single YAML document, which requires to read it as a whole before it can be
processed (displayed, filtered, etc.). This is a legacy mode, which proved to be
slow and memory-consuming.

This option implies that YAML trace log was produces by B<m0tracedump> with
B<-S> option.

=item B<-Y|--yaml-output>

Don't perform any parsing of input stream, simply redirect it as output. Because
input is always in YAML format, this produces a raw YAML output.

=item B<-W|--workers=I<num>>

Number of workers to start for trace records processing. By default equals to
a number of available CPU cores. Parallel record processing can be disabled
with I<num> set to C<0>.

=item B<--no-pager>

Don't use pager (C<less>) to display results.

=item B<--flush-output>

Flush output file after writing each trace record.

=item B<--no-relpath>

Use full path when displaying name of a source file to which a trace record
belongs.

=item B<-w|--column-width=I<num>>

Set column width for columns which support it (so far there is only one -
file/line/func from 'med' format). Use C<-w0> for minimal width. By default it's
set to I<30>.

=item B<-c|-C|--color=I<MODE>>

Controls, whether to colorize output, depending on trace level of each record.
MODE can be:

=over 4

=item *
I<auto> - detect type of output file (terminal, file, or pipe) and use colors if
output goes to a terminal, this is default;

=item *
I<always> - always use colors no matter what is the type of output file,
same as C<-c>;

=item *
I<never> - never use colors, same as C<-C>.

=back

=item B<-d>

Use hard-coded C</usr/bin/> path for m0tracedump (it can be handy when there are
two versions of m0tracedump in the PATH - one from rpm and one from workdir).

=item B<-L|--log-dir=I<DIR>>

Path to a directory where to look for trace files, by default is C</var/log/mero>.

=item B<-k|--kdump>

Indicates that input file is a kernel crash dump, produced by C<kdump>.

=item B<-I|--module-image=I<FILE>>

Core image of m0mero.ko module, required to analize kernel space trace logs.

=item B<-H|--dump-header>

Only print trace file header and exit. Option --pager is ignored.

=item B<-F|--follow>

Monitor trace file and print trace records as soon as they appear in the file.
Starts at the current position in the trace buffer.

=item B<-M|--match-only>

By default, trace records with level I<warn+> are always printed disregarding
whether they match filters (like B<--file>, B<--func>, B<--msg>, etc.) or not.
With this option, only records that match filters are printed.

=item B<-f|--format=I<FMT>>

Controls amount of information, which is displayed for each trace record, and
how it looks. Possible values for FMT are: I<short>, I<med> (default one),
I<full> and I<custom:STR>. The last one is special, it accepts a format
string, which goes after a colon, and it may have the following placeholders:

=over 4

=item *
%n:  newline

=item *
%t:  horizontal tab

=item *
%N:  record_Num

=item *
%T:  Timestamp

=item *
%p:  pid

=item *
%a:  stack_Addr

=item *
%s:  Subsystem

=item *
%l:  Level

=item *
%f:  Func

=item *
%F:  File

=item *
%L:  Line

=item *
%m:  Msg

=back

Example:

  m0trace --format=med
  m0trace --format='custom:Num[%N] Stack[%a]: %t%m'

=item B<-a|--stackaddr-width>

Width of stack-address column.

=item B<-A|--stackaddr-hl>

Number of color-highlighted positions in stack adress.

=item B<-l|--level=I<LVL>>

Display only trace records with specified log level. I<LVL> is a coma separated
list of log levels, where each level can be one of:

=over 4

=item *
I<fatal>

=item *
I<error>

=item *
I<warn>

=item *
I<notice>

=item *
I<info>

=item *
I<debug>

=item *
I<call>

=back

A special log levels with '+' at the end of level name can be used. They mean
"all levels from current and above". For example, I<warn+> means displaying
I<warn>, I<error> and I<fatal> levels. The default one is I<call+>, which means
displaying records from all levels.

Example:

  m0trace --format=call,error+

=item B<-s|--subsys=I<SBS>>

Display only trace records from specified Mero subsystem. I<SBS> is a coma
separated list of subsystem names. If I<SBS> starts with C<!> it means reverse -
display all subsystems except specified. A special subsystem I<all> means display
all subsystems (this is the default).

=item B<-e|--file=I<FL>>

Display only trace records from specified source file. I<FL> is a C<perl> regex.

Example:

  m0trace -F 'init\.c'
  m0trace -F '^fop/|^fom/'

=item B<-u|--func=I<FUN>>

Display only trace records from specified function. I<FUN> is a C<perl> regex.

Example:

  m0trace -U '^m0_alloc$'
  m0trace -U '(?<!m0_)(?:alloc|free)'

=item B<-m|--msg=I<MSG>>

Display only trace records, which have specified message. I<MSG> is a C<perl>
regex.

Example:

  m0trace -M 'Sesstion created'
  m0trace -M 'slot \x+ nr_items [1-3]'

=item B<-h|--help>

Print this help summary.

=item B<--usage>

Print usage line of this summary.

=item B<--man>

Print the complete manpage.

=back

=cut
